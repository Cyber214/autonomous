# core/trading_controller.py - COMPLETE FIXED VERSION
# ============================================================
# ==================== TRADING CONTROLLER ====================
# ============================================================
import asyncio
import csv
import os
import time
import uuid
from datetime import datetime
from typing import Dict, List
import pandas as pd
from utils.logger import get_logger
from core.signal import TradingSignal
from core.production_risk_manager import ProductionRiskManager, MarketRegime
from core.saved_strategies import strategy_fvg, range_scalp_4h, strategy_ma, analyze_all_strategies

logger = get_logger()


class TradingController:
    def __init__(self, strategy_engine, protection, config):
        self.strategy_engine = strategy_engine
        self.protection = protection
        self.config = config
        self.is_paused = False
        self.trade_log = []
        self.trade_amount = config["strategy"]["trade_amount"]
        self.trade_duration = 300
        self.duration_source = "manual"
        self.duration_last_updated = datetime.now()
        self.last_trade_time = 0
        self.trade_cooldown = 60
        self.telegram = None
        self.real_balance = None

        # Multi-strategy system
        self.enabled_strategies = {
            "FVG": True,
            "RANGE_4H": True,
            "MA": True
        }
        self.price_history = []

        self.shutting_down = False
        self.active_protection_reason = None
        
        self.symbol = config["bybit"]["symbol"]
        
        self._ensure_logs_directory()
        self.setup_graceful_shutdown()

    # --------------------------------------------------------
    # =================== SHUTDOWN / SETUP ===================
    # --------------------------------------------------------
    def setup_graceful_shutdown(self):
        import signal

        def shutdown_handler(signum, frame):
            logger.info("üõë Graceful shutdown initiated...")
            self.shutting_down = True
            self.pause()

        signal.signal(signal.SIGINT, shutdown_handler)
        print("üõë Use Ctrl+C to stop safely. DO NOT use Ctrl+Z!")

    def _ensure_logs_directory(self):
        if not os.path.exists('logs'):
            os.makedirs('logs')

    # --------------------------------------------------------
    # ================= MULTI-STRATEGY METHODS ================
    # --------------------------------------------------------
    def update(self, price, high, low, volume):
        """Update price history for all strategies"""
        candle = {
            "open": price,
            "high": high,
            "low": low,
            "close": price,
            "volume": volume
        }
        self.price_history.append(candle)
        
        # Keep only last 500 candles
        self.price_history = self.price_history[-500:]
    
    def _df(self):
        """Convert price_history to DataFrame for strategies"""
        if not self.price_history:
            return pd.DataFrame()
        return pd.DataFrame(self.price_history)
    
    async def analyze_and_signal(self, market_data: dict) -> TradingSignal:
        """Run all enabled strategies and combine signals"""
        # First, update price history if provided
        if isinstance(market_data, dict):
            current_price = market_data.get('quote') or market_data.get('current') or market_data.get('price', 0)
            high = market_data.get('high', current_price)
            low = market_data.get('low', current_price)
            volume = market_data.get('volume', 0)
            
            if current_price > 0:
                self.update(current_price, high, low, volume)
        
        # Convert to DataFrame
        df = self._df()
        
        if df.empty or len(df) < 50:
            return TradingSignal.hold_signal(
                symbol=self.symbol,
                reason="Insufficient data"
            )
        
        signals = []
        
        # Run enabled strategies
        if self.enabled_strategies.get("FVG", True):
            result_fvg = strategy_fvg(df)
            if result_fvg["direction"] != "HOLD":
                signals.append(result_fvg)
        
        if self.enabled_strategies.get("RANGE_4H", True):
            result_range = range_scalp_4h(df)
            if result_range["direction"] != "HOLD":
                signals.append(result_range)
        
        if self.enabled_strategies.get("MA", True):
            result_ma = strategy_ma(df)
            if result_ma["direction"] != "HOLD":
                signals.append(result_ma)
        
        # Resolve signals using consensus
        final_signal = self._resolve_signals(signals, df)
        
        return final_signal
    
    def _resolve_signals(self, signals: List[Dict], df: pd.DataFrame) -> TradingSignal:
        """Resolve multiple strategy signals into one TradingSignal"""
        if not signals:
            return TradingSignal.hold_signal(
                symbol=self.symbol,
                reason="No strategy signals generated"
            )
        
        # Get current price
        current_price = df.iloc[-1]['close'] if len(df) > 0 else 0
        
        # Count votes
        buy_votes = sum(1 for s in signals if s["direction"] == "BUY")
        sell_votes = sum(1 for s in signals if s["direction"] == "SELL")
        
        # Calculate consensus and strength
        total_votes = len(signals)
        consensus = max(buy_votes, sell_votes) / total_votes
        avg_strength = sum(s["signal_strength"] for s in signals) / total_votes
        
        # Determine direction
        if buy_votes > sell_votes:
            direction = "BUY"
        elif sell_votes > buy_votes:
            direction = "SELL"
        else:
            # Tie - check individual strengths
            buy_strength = sum(s["signal_strength"] for s in signals if s["direction"] == "BUY")
            sell_strength = sum(s["signal_strength"] for s in signals if s["direction"] == "SELL")
            direction = "BUY" if buy_strength >= sell_strength else "SELL"
        
        # Calculate confidence (consensus √ó average strength)
        confidence = consensus * avg_strength
        
        # Calculate stop loss and target (2% stop, 6% target for 3:1 R:R)
        if direction == "BUY":
            stop_loss = current_price * 0.99
            target = current_price * 1.06
        else:
            stop_loss = current_price * 1.01
            target = current_price * 0.94
        
        # Build reason string
        strategy_names = [s.get("strategy", "UNKNOWN") for s in signals]
        reason = {
            "strategies": strategy_names,
            "buy_votes": buy_votes,
            "sell_votes": sell_votes,
            "consensus": consensus,
            "individual_signals": signals
        }
        
        logger.info(f"üì° Multi-strategy signal: {direction} (confidence: {confidence:.2f}, strategies: {strategy_names})")
        
        return TradingSignal(
            symbol=self.symbol,
            direction=direction,
            setup="MULTI_STRATEGY",
            entry_zone=(current_price * 0.999, current_price * 1.001),
            stop_reference=stop_loss,
            target_reference=target,
            confidence=confidence,
            reason=reason,
            metadata={
                "consensus": consensus,
                "strategy_count": total_votes
            }
        )

    # --------------------------------------------------------
    # ================== PROTECTION CHECK METHOD =============
    # --------------------------------------------------------
    def _check_protection(self):
        """
        Check if protection system allows trading.
        Returns tuple of (can_trade, reason_if_blocked)
        """
        # First check if protection has can_trade method
        if hasattr(self.protection, 'can_trade'):
            can_trade = self.protection.can_trade()
            if not can_trade and hasattr(self.protection, 'get_block_reason'):
                reason = self.protection.get_block_reason()
                return False, reason
            return can_trade, None
        
        # Fallback: Check using should_shutdown method
        if hasattr(self.protection, 'should_shutdown'):
            if self.protection.should_shutdown():
                # Build detailed reason
                reasons = []
                
                if hasattr(self.protection, 'loss_limit_triggered'):
                    if self.protection.loss_limit_triggered():
                        reasons.append("Daily loss limit")
                
                if hasattr(self.protection, 'consecutive_loss_triggered'):
                    if self.protection.consecutive_loss_triggered():
                        reasons.append("Consecutive losses")
                
                if hasattr(self.protection, 'check_abnormal_volatility'):
                    if self.protection.check_abnormal_volatility():
                        reasons.append("Abnormal volatility")
                
                if hasattr(self.protection, 'schedule_blocked'):
                    if self.protection.schedule_blocked():
                        reasons.append("Outside trading hours")
                
                reason = " | ".join(reasons) if reasons else "Protection triggered"
                return False, reason
        
        # Default: Allow trading
        return True, None

    # --------------------------------------------------------
    # =========== TRADE AMOUNT / DURATION CONTROLS ===========
    # --------------------------------------------------------
    def set_trade_amount(self, amount):
        self.trade_amount = float(amount)
        print(f"üí∞ Trade amount set to: ${self.trade_amount}")

    def set_trade_duration(self, duration, source="manual"):
        self.trade_duration = int(duration)
        self.duration_source = source
        self.duration_last_updated = datetime.now()
        minutes = duration / 60
        print(f"‚è±Ô∏è Trade duration set to: {minutes:.1f} minutes ({duration} seconds) via {source}")

    # --------------------------------------------------------
    # ================== VOLATILITY ANALYSIS =================
    # --------------------------------------------------------
    def analyze_market_volatility(self, df):
        if len(df) < 100:
            return 300
        volatility = df['price'].rolling(50).std().iloc[-1]
        if volatility > 2.0:
            return 180
        elif volatility < 0.5:
            return 600
        else:
            return 300

    def compute_ml_duration(self):
        """Use ML confidence + market stats to choose trade duration"""
        df = self.strategy_engine._df()
        if len(df) < 120:
            return max(180, min(600, self.trade_duration))

        _, strategy_results = self.strategy_engine.decide()
        ml_votes = [strategy_results[k] for k in strategy_results if k != "s7_trend_momentum"]
        buy_votes = ml_votes.count("BUY")
        sell_votes = ml_votes.count("SELL")
        vote_strength = max(buy_votes, sell_votes) / max(1, len(ml_votes))

        price_series = df.price
        volatility = price_series.pct_change().rolling(60).std().iloc[-1]
        trend_window = min(len(price_series) - 1, 120)
        trend_strength = abs(price_series.iloc[-1] - price_series.iloc[-trend_window]) / price_series.iloc[-trend_window]

        duration = 300
        if vote_strength >= 0.8:
            duration = 180 if volatility > 0.001 else 240
        elif vote_strength <= 0.5:
            duration = 420 if trend_strength < 0.001 else 360
        else:
            duration = 300 if volatility < 0.001 else 240

        if trend_strength < 0.0007 and volatility < 0.0008:
            duration = 600
        if trend_strength > 0.003 and vote_strength >= 0.7:
            duration = 180

        return max(120, min(900, duration))

    def duration_status(self):
        return {
            "seconds": self.trade_duration,
            "minutes": self.trade_duration / 60,
            "source": self.duration_source,
            "last_updated": self.duration_last_updated.strftime("%Y-%m-%d %H:%M:%S")
        }

    # --------------------------------------------------------
    # =================== COOLDOWN HANDLING ==================
    # --------------------------------------------------------
    def can_trade(self):
        current_time = time.time()
        return (current_time - self.last_trade_time) >= self.trade_cooldown

    def update_trade_time(self):
        self.last_trade_time = time.time()

    # --------------------------------------------------------
    # ================== PAUSE / RESUME / STATUS =============
    # --------------------------------------------------------
    def pause(self):
        self.is_paused = True
        self.strategy_engine.is_paused = True

    def resume(self):
        self.is_paused = False
        self.strategy_engine.is_paused = False

    def status(self):
        total_signals = len(self.trade_log)
        winning_signals = len([t for t in self.trade_log if t.get('profit_loss', 0) > 0])
        total_profit = sum(trade.get('profit_loss', 0) for trade in self.trade_log)

        # Get risk manager report
        risk_report = self.risk_manager.get_risk_report()

        return {
            "paused": self.is_paused,
            "symbol": self.symbol,
            "daily_loss": self.protection.daily_loss,
            "consecutive_losses": self.protection.consecutive_losses,
            "within_trading_hours": self.protection.within_trading_hours(),
            "main_decider_enabled": self.strategy_engine.main_decider_enabled,
            "total_signals": total_signals,
            "winning_signals": winning_signals,
            "win_rate": (winning_signals / total_signals * 100) if total_signals > 0 else 0,
            "total_profit": total_profit,
            "max_daily_loss": self.protection.max_daily_loss,
            "max_consecutive_losses": self.protection.max_consecutive_losses,
            "account_balance": self.real_balance,
            "trade_cooldown_active": not self.can_trade(),
            # Production risk management metrics
            "risk_management": {
                "current_drawdown": risk_report['risk_metrics']['current_drawdown'],
                "max_drawdown": risk_report['risk_metrics']['max_drawdown'],
                "daily_pnl": risk_report['risk_metrics']['daily_pnl'],
                "weekly_pnl": risk_report['risk_metrics']['weekly_pnl'],
                "sharpe_ratio": risk_report['risk_metrics']['sharpe_ratio'],
                "win_rate": risk_report['risk_metrics']['win_rate'],
                "volatility": risk_report['risk_metrics']['volatility'],
                "market_regime": risk_report['risk_metrics']['market_regime'],
                "circuit_breaker_level": risk_report['circuit_breakers']['level'],
                "circuit_breaker_reason": risk_report['circuit_breakers']['reason'],
                "current_leverage_limit": risk_report['position_limits']['max_leverage']
            }
        }

    # --------------------------------------------------------
    # =============== SCHEDULE / LOSS LIMIT UPDATE ===========
    # --------------------------------------------------------
    def update_schedule(self, start, end):
        self.protection.update_schedule(start, end)
        from utils.config_loader import persist_schedule_to_env
        persist_schedule_to_env(start, end)

    def update_loss_limit(self, limit):
        self.protection.max_daily_loss = float(limit)
        from utils.config_loader import persist_loss_limit_to_env
        persist_loss_limit_to_env(float(limit))

    # --------------------------------------------------------
    # ================ UPDATED: MARKET CHANGE ================
    # --------------------------------------------------------
    async def change_market(self, new_symbol):
        """Change trading symbol for Bybit."""
        normalized = new_symbol.strip().upper()
        if not normalized:
            raise ValueError("Symbol cannot be empty")
        
        self.symbol = normalized

        self.config["bybit"]["symbol"] = normalized
        
        self.strategy_engine.reset_history()
        
        logger.info(f"‚úÖ Market switched to {normalized} (Bybit)")
        return normalized

    def main_decider(self, enabled):
        self.strategy_engine.main_decider_enabled = enabled

    # --------------------------------------------------------
    # =================== PROTECTION ALERTS ==================
    # --------------------------------------------------------
    async def notify_protection(self, reason, telegram):
        """Send protection alert only when reason changes"""
        if self.active_protection_reason != reason:
            self.active_protection_reason = reason
            await telegram.send(f"üö® AUTO-PAUSE: {reason}")

    def clear_protection_alert(self):
        self.active_protection_reason = None

    # --------------------------------------------------------
    # =================== SIGNAL LOGGING / CSV ===============
    # --------------------------------------------------------
    def log_signal(self, signal: TradingSignal, result: str = "GENERATED"):
        """Log signal instead of trade."""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'symbol': signal.symbol,
            'direction': signal.direction,
            'setup': signal.setup,
            'confidence': signal.confidence,
            'entry_zone': list(signal.entry_zone) if signal.entry_zone else None,
            'stop_reference': signal.stop_reference,
            'target_reference': signal.target_reference,
            'result': result,
            'reason': signal.reason
        }

        csv_path = 'logs/signals.csv'
        file_exists = os.path.isfile(csv_path)

        fieldnames = [
            'timestamp', 'symbol', 'direction', 'setup', 'confidence',
            'entry_zone', 'stop_reference', 'target_reference', 'result', 'reason'
        ]

        with open(csv_path, 'a', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(log_entry)

        self.trade_log.append(log_entry)
        return log_entry

